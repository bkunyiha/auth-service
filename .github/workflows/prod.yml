name: Build, Test and Deploy to Prod

# Trigger the workflow when changes are pushed to the main branch
on:
  push:
    branches:
      - main
  workflow_dispatch:  # Allow manual triggering

# During Build phase, force SQLx offline mode to prevent compile-time database connection errors
env:
  SQLX_OFFLINE: true

jobs:
  # Build and test job - runs tests and builds Docker images
  build:
    runs-on: ubuntu-latest

    steps:
      # Checkout code from the repository
    - name: Checkout code
      uses: actions/checkout@v4

    - name: Early disk diagnostic
      run: |
        echo "Disk usage at job start"
        df -h /
        df -h /run || true
        df -i / || true
        echo "Top dirs in /run"
        sudo du -sh /run/* 2>/dev/null | sort -h | tail -n 20 || true

    - name: Aggressive but safe cleanup to free disk
      run: |
        # Remove stopped containers, dangling images, build cache and unused volumes
        docker container prune -f || true
        docker image prune -af || true
        docker volume prune -f || true
        docker builder prune -af || true
        # Free GitHub runner toolcache and tmp which can consume space
        sudo rm -rf /opt/hostedtoolcache/* || true
        sudo rm -rf /tmp/* || true

    - name: Disk diagnostic after cleanup
      run: |
        echo "Disk usage after cleanup"
        df -h /
        df -h /run || true
        docker system df || true

    - name: Start Postgres and Redis (after cleanup)
      run: |
        docker run --name ci-postgres -e POSTGRES_USER=postgres \
          -e POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }} \
          -e POSTGRES_DB=postgres -p 5432:5432 -d postgres:15.2-alpine
        docker run --name ci-redis -p 6379:6379 -d redis:7.0-alpine

        # Wait for Postgres readiness
        for i in $(seq 1 30); do
          docker exec ci-postgres pg_isready -U postgres && break
          echo "Waiting for postgres..."
          sleep 1
        done

        # Wait for Redis readiness
        for i in $(seq 1 30); do
          docker exec ci-redis redis-cli ping | grep -q PONG && break
          echo "Waiting for redis..."
          sleep 1
        done

    - name: Set env for tests
      run: |
        echo "DATABASE_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@127.0.0.1:5432/postgres" >> $GITHUB_ENV
        echo "REDIS_URL=redis://127.0.0.1:6379" >> $GITHUB_ENV

    # Cache Rust dependencies to speed up build times (reduced cache to avoid large target dirs)
    - name: Cache Rust registry and cargo
      uses: actions/cache@v4
      with:
        path: |
          app-service/.cargo/registry
          auth-service/.cargo/registry
          ~/.cargo/bin
        key: ${{ runner.os }}-cargo-registry-${{ hashFiles('**/Cargo.lock') }}
        restore-keys: ${{ runner.os }}-cargo-registry-

    # Install Rust toolchain
    - name: Install Rust
      run: rustup update stable && rustup default stable

    # Build and test app-service (main application)
    - name: Build and test app-service code
      working-directory: ./app-service
      run: |
        cargo build --verbose
        cargo test --verbose

    # Build and test auth-service (authentication service)
    - name: Build and test auth-service code
      working-directory: ./auth-service
      run: |
        export JWT_SECRET=secret
        export APP_SERVICE_HOST=0.0.0.0:8000
        export DATABASE_URL=postgres://postgres:${{ secrets.POSTGRES_PASSWORD }}@127.0.0.1:5432/postgres
        cargo build --verbose
        cargo test --verbose

    # Set up Docker Buildx for multi-platform builds
    - name: Set up Docker Buildx
      uses: docker/setup-buildx-action@v3

    # Authenticate with Docker Hub for image pushing
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # Clean up Docker to free disk space before building images
    - name: Clean up Docker
      run: |
        docker container prune -f
        docker image prune -af
        docker volume prune -f
        docker system prune -af

    # Build and push Docker images using Docker Bake (reads compose.yml)
    - name: Build and push Docker images
      uses: docker/bake-action@v2.3.0
      with:
        push: true
        files: |
          compose.yml
          compose.override.yml
        set: |
          *.cache-from=type=gha
          *.cache-to=type=gha,mode=max
          *.platform=linux/amd64,linux/arm64

  # Deployment job - deploys to production server after successful build
  deploy:
    needs: build  # Wait for build job to complete
    runs-on: ubuntu-latest

    steps:
    - name: Checkout code
      uses: actions/checkout@v4

    # Authenticate with Docker Hub (needed for pulling images on server)
    - name: Log in to Docker Hub
      uses: docker/login-action@v3
      with:
        username: ${{ secrets.DOCKER_USERNAME }}
        password: ${{ secrets.DOCKER_PASSWORD }}

    # Install sshpass for password-based SSH authentication
    - name: Install sshpass
      run: sudo apt-get install sshpass

    # Copy compose.yml to production server
    - name: Copy compose.yml to droplet
      run: sshpass -v -p ${{ secrets.DROPLET_PASSWORD }} scp -o StrictHostKeyChecking=no compose.yml root@${{ vars.DROPLET_IP }}:~

    # Deploy to production server via SSH
    - name: Deploy
      uses: appleboy/ssh-action@v1.0.3
      with:
        host: ${{ vars.DROPLET_IP }}
        username: root
        password: ${{ secrets.DROPLET_PASSWORD }}
        script: |
          cd ~
          # Set environment variables for production
          export JWT_SECRET=${{ secrets.JWT_SECRET }}
          export APP_SERVICE_HOST=${{ vars.APP_SERVICE_HOST }}
          export AUTH_SERVICE_IP=${{ vars.DROPLET_IP }}
          export POSTGRES_PASSWORD=${{ secrets.POSTGRES_PASSWORD }}
          export POSTMARK_AUTH_TOKEN=${{ secrets.POSTMARK_AUTH_TOKEN }}
          export EMAIL_SERVICE_HOST=${{ vars.EMAIL_SERVICE_HOST }}
          export EMAIL_FROM_USER=${{ vars.EMAIL_FROM_USER }}
          export EMAIL_TIMEOUT_MILLIS=${{ vars.EMAIL_TIMEOUT_MILLIS }}

          # Stop existing containers (best-effort)
          docker compose down || true

          # Aggressive cleanup to free space and remove stale artifacts
          docker image prune -af || true
          docker container prune -f || true
          docker volume prune -f || true
          # system prune including volumes; some older dockers may not accept --volumes -> fallback to without
          docker system prune -af --volumes || docker system prune -af || true

          if [ -e /var/run/docker/runtime-runc ]; then
            rm -f /var/run/docker/runtime-runc
          fi

          if [ -e /var/run/docker/runtime-runc ] || [ -e /var/run/docker/containerd ]; then
            echo "Detected stale docker runtime state â€” attempting to restart docker daemon"
            sudo systemctl restart docker || sudo service docker restart || true
            sleep 3
          fi

          # Report disk usage for debugging
          df -h || true

          # Pull latest images and start fresh containers
          docker compose pull
          docker compose up -d
